# Pascal's Triangle & Function Basics â€” Handwritten-Style Notes

---

## 1ï¸âƒ£ FUNCTION BASICS

### ğŸ”¹ What is a Function?

* Block of code performing a **specific task**
* Can be **reused multiple times**
* Follows **DRY principle** (Don't Repeat Yourself)

### ğŸ”¹ Syntax

```cpp
return_type function_name(parameters) {
    // code
}
```

### ğŸ”¹ Return Types

| Return Type | Meaning               |
| ----------- | --------------------- |
| void        | No return value       |
| int         | Returns integer       |
| float       | Returns decimal       |
| long long   | Returns large integer |

### ğŸ”¹ Example

```cpp
void greet() {
    cout << "Hello";
}
```

### ğŸ”¹ Mind Map

```
Function
â”‚
â”œâ”€â”€ With return
â”œâ”€â”€ Without return (void)
â”œâ”€â”€ With parameters
â”œâ”€â”€ Without parameters
â””â”€â”€ Reusability (DRY)
```

---

## 2ï¸âƒ£ PASCAL'S TRIANGLE

### ğŸ”¹ Definition

* Each row starts & ends with **1**
* Middle elements = **sum of two above**
* Element = **Combination (nCr)**

Example:

```
        1
      1   1
    1   2   1
  1   3   3   1
1   4   6   4   1
```

### ğŸ”¹ Formula

* **Combination:** nCr = n! / (r! * (n-r)!)
* **Optimized (no factorial):** value = value * (n - col) / (col + 1)

### ğŸ”¹ Mind Map

```
Pascal Triangle
â”‚
â”œâ”€â”€ Single Element â†’ nCr (O(r))
â”œâ”€â”€ Nth Row â†’ Optimized O(n)
â”œâ”€â”€ Full Triangle
â”‚     â”œâ”€â”€ Factorial âŒ O(nÂ³)
â”‚     â””â”€â”€ Optimized âœ… O(nÂ²)
â””â”€â”€ Indexing
      â”œâ”€â”€ 0-based â†’ nCr
      â””â”€â”€ 1-based â†’ (n-1)C(r-1)
```

---

## 3ï¸âƒ£ Nth Row (O(n))

```cpp
#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    long long ans = 1;
    cout << ans << " ";

    for (int col = 1; col < n; col++) {
        ans = ans * (n - col) / col;
        cout << ans << " ";
    }
    return 0;
}
```

* **Input:** n = 4
* **Output:** 1 3 3 1
* **Time:** O(n), **Space:** O(1)

---

## 4ï¸âƒ£ Element at Given Position (n, r)

```cpp
#include<iostream>
using namespace std;

int main() {
    int n, r;
    cin >> n >> r;

    long long ans = 1;
    for (int i = 0; i < r; i++) {
        ans = ans * (n - i) / (i + 1);
    }

    cout << ans;
    return 0;
}
```

* **0-based indexing** â†’ Element = nCr
* **Time:** O(r), **Space:** O(1)

---

## 5ï¸âƒ£ Full Pascal Triangle (Optimized O(nÂ²))

```cpp
#include<iostream>
#include<vector>
using namespace std;

int main() {
    int n;
    cin >> n;

    for (int i = 0; i <= n; i++) {
        long long ans = 1;
        for (int col = 0; col <= i; col++) {
            cout << ans << " ";
            ans = ans * (i - col) / (col + 1);
        }
        cout << endl;
    }
    return 0;
}
```

* **Time:** O(nÂ²)
* **Space:** O(1)

---

## 6ï¸âƒ£ Complexity Comparison

| Task                      | Time  | Space |
| ------------------------- | ----- | ----- |
| Single element            | O(r)  | O(1)  |
| Nth row                   | O(n)  | O(1)  |
| Full triangle (optimized) | O(nÂ²) | O(1)  |
| Full triangle (factorial) | O(nÂ³) | O(1)  |

---

## 7ï¸âƒ£ Quick Interview Notes

* Value at position (n, r) = nCr
* Full triangle cannot be O(n) (elements = O(nÂ²))
* Optimized nCr avoids factorial, reduces complexity
* Functions â†’ code reuse & cleaner logic

---

## âœ… Key Takeaways

* **Function** â†’ reuse, DRY principle
* **Pascal Triangle** â†’ combination logic
* **Optimized formula** â†’ O(n) / O(nÂ²)
* **Interview ready concepts** â†’ nCr, row, full triangle
* **Indexing** â†’ 0-based / 1-based clear

---
